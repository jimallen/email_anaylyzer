import { describe, it, expect, vi } from 'vitest';
import { formatSuccessEmail, formatErrorEmail } from './email-formatter';
import {
  ContentProcessingError,
  LLMError,
  ERROR_CODES,
  LLM_ERROR_CODES,
  createNoContentError,
  createDownloadFailedError,
  createInvalidFormatError,
  createSizeExceededError,
  createLLMTimeoutError,
  createLLMNetworkError,
  createLLMHTTPError,
  createLLMInvalidResponseError,
} from '../lib/errors';

describe('Email Formatter', () => {
  const testRecipient = 'user@company.com';
  const testSubject = 'Draft: Customer Follow-up';
  const testFeedback = 'Your email is clear and professional. Consider adding a specific call-to-action.';

  describe('formatSuccessEmail', () => {
    describe('Subject line formatting', () => {
      it('should add "Re:" prefix to original subject', () => {
        const result = formatSuccessEmail(testRecipient, testSubject, testFeedback);

        expect(result.subject).toBe('Re: Draft: Customer Follow-up');
      });

      it('should use default subject when original is empty', () => {
        const result = formatSuccessEmail(testRecipient, '', testFeedback);

        expect(result.subject).toBe('Re: Your email draft');
      });

      it('should use default subject when original is whitespace', () => {
        const result = formatSuccessEmail(testRecipient, '   ', testFeedback);

        expect(result.subject).toBe('Re: Your email draft');
      });

      it('should handle long subject lines', () => {
        const longSubject = 'A'.repeat(200);
        const result = formatSuccessEmail(testRecipient, longSubject, testFeedback);

        expect(result.subject).toBe(`Re: ${longSubject}`);
      });

      it('should preserve special characters in subject', () => {
        const specialSubject = 'Re: FW: [URGENT] Customer Issue #123 - $$ Amount';
        const result = formatSuccessEmail(testRecipient, specialSubject, testFeedback);

        expect(result.subject).toBe(`Re: ${specialSubject}`);
      });
    });

    describe('Email body structure', () => {
      it('should include greeting', () => {
        const result = formatSuccessEmail(testRecipient, testSubject, testFeedback);

        expect(result.body).toContain('Hi,');
      });

      it('should include intro text', () => {
        const result = formatSuccessEmail(testRecipient, testSubject, testFeedback);

        expect(result.body).toContain("I've analyzed your email draft and here's my feedback:");
      });

      it('should include feedback verbatim', () => {
        const result = formatSuccessEmail(testRecipient, testSubject, testFeedback);

        expect(result.body).toContain(testFeedback);
      });

      it('should include footer separator', () => {
        const result = formatSuccessEmail(testRecipient, testSubject, testFeedback);

        expect(result.body).toContain('---');
      });

      it('should include footer text', () => {
        const result = formatSuccessEmail(testRecipient, testSubject, testFeedback);

        expect(result.body).toContain('This analysis was generated by Email Analyzer');
        expect(result.body).toContain('If you have questions, contact your CMO.');
      });

      it('should have proper structure order', () => {
        const result = formatSuccessEmail(testRecipient, testSubject, testFeedback);

        const hiIndex = result.body.indexOf('Hi,');
        const introIndex = result.body.indexOf("I've analyzed");
        const feedbackIndex = result.body.indexOf(testFeedback);
        const separatorIndex = result.body.indexOf('---');
        const footerIndex = result.body.indexOf('This analysis');

        expect(hiIndex).toBeLessThan(introIndex);
        expect(introIndex).toBeLessThan(feedbackIndex);
        expect(feedbackIndex).toBeLessThan(separatorIndex);
        expect(separatorIndex).toBeLessThan(footerIndex);
      });
    });

    describe('Feedback preservation', () => {
      it('should preserve multi-line feedback', () => {
        const multiLineFeedback = `Line 1: Good opening
Line 2: Add more detail
Line 3: Strong closing`;

        const result = formatSuccessEmail(testRecipient, testSubject, multiLineFeedback);

        expect(result.body).toContain('Line 1: Good opening');
        expect(result.body).toContain('Line 2: Add more detail');
        expect(result.body).toContain('Line 3: Strong closing');
      });

      it('should preserve whitespace in feedback', () => {
        const feedbackWithSpaces = '  Start with spaces\n\nDouble newline\n  More spaces  ';

        const result = formatSuccessEmail(testRecipient, testSubject, feedbackWithSpaces);

        expect(result.body).toContain(feedbackWithSpaces);
      });

      it('should preserve special characters in feedback', () => {
        const specialFeedback = 'Use @mentions, #hashtags, $prices, & ampersands!';

        const result = formatSuccessEmail(testRecipient, testSubject, specialFeedback);

        expect(result.body).toContain(specialFeedback);
      });

      it('should handle empty feedback', () => {
        const result = formatSuccessEmail(testRecipient, testSubject, '');

        expect(result.body).toContain('Hi,');
        expect(result.body).toContain('---');
        // Feedback section should be empty but structure should remain
      });

      it('should handle very long feedback', () => {
        const longFeedback = 'A'.repeat(5000);

        const result = formatSuccessEmail(testRecipient, testSubject, longFeedback);

        expect(result.body).toContain(longFeedback);
      });
    });

    describe('Return value structure', () => {
      it('should return correct to address', () => {
        const result = formatSuccessEmail(testRecipient, testSubject, testFeedback);

        expect(result.to).toBe(testRecipient);
      });

      it('should return all required fields', () => {
        const result = formatSuccessEmail(testRecipient, testSubject, testFeedback);

        expect(result).toHaveProperty('to');
        expect(result).toHaveProperty('subject');
        expect(result).toHaveProperty('body');
      });

      it('should not modify input parameters', () => {
        const originalTo = testRecipient;
        const originalSubject = testSubject;
        const originalFeedback = testFeedback;

        formatSuccessEmail(testRecipient, testSubject, testFeedback);

        expect(testRecipient).toBe(originalTo);
        expect(testSubject).toBe(originalSubject);
        expect(testFeedback).toBe(originalFeedback);
      });
    });

    describe('Body length validation', () => {
      it('should not warn for normal-length body', () => {
        const mockLogger = {
          info: vi.fn(),
          warn: vi.fn(),
        } as any;

        const normalFeedback = 'A'.repeat(1000);
        formatSuccessEmail(testRecipient, testSubject, normalFeedback, mockLogger);

        expect(mockLogger.warn).not.toHaveBeenCalled();
      });

      it('should warn when body exceeds 10,000 characters', () => {
        const mockLogger = {
          info: vi.fn(),
          warn: vi.fn(),
        } as any;

        // Create feedback that will result in >10,000 char body
        const longFeedback = 'A'.repeat(10000);
        formatSuccessEmail(testRecipient, testSubject, longFeedback, mockLogger);

        expect(mockLogger.warn).toHaveBeenCalledWith(
          expect.objectContaining({
            to: testRecipient,
            subject: expect.any(String),
            bodyLength: expect.any(Number),
          }),
          'Success email body exceeds 10,000 characters'
        );
      });

      it('should not truncate long body', () => {
        const longFeedback = 'A'.repeat(15000);
        const result = formatSuccessEmail(testRecipient, testSubject, longFeedback);

        // Body should contain all feedback
        expect(result.body).toContain(longFeedback);
        expect(result.body.length).toBeGreaterThan(15000);
      });
    });

    describe('Logging behavior', () => {
      it('should log metadata for success email', () => {
        const mockLogger = {
          info: vi.fn(),
          warn: vi.fn(),
        } as any;

        formatSuccessEmail(testRecipient, testSubject, testFeedback, mockLogger);

        expect(mockLogger.info).toHaveBeenCalledWith(
          expect.objectContaining({
            to: testRecipient,
            subject: 'Re: Draft: Customer Follow-up',
            bodyLength: expect.any(Number),
          }),
          'Success email formatted'
        );
      });

      it('should not log actual feedback content', () => {
        const mockLogger = {
          info: vi.fn(),
          warn: vi.fn(),
        } as any;

        const secretFeedback = 'SECRET_SENSITIVE_INFO_12345';
        formatSuccessEmail(testRecipient, testSubject, secretFeedback, mockLogger);

        const allCalls = [
          ...mockLogger.info.mock.calls,
          ...mockLogger.warn.mock.calls,
        ];

        allCalls.forEach((call) => {
          const logData = call[0];
          if (typeof logData === 'object') {
            const stringified = JSON.stringify(logData);
            expect(stringified).not.toContain(secretFeedback);
          }
        });
      });

      it('should work without logger', () => {
        // Should not throw
        expect(() => {
          formatSuccessEmail(testRecipient, testSubject, testFeedback);
        }).not.toThrow();
      });

      it('should include correct body length in log', () => {
        const mockLogger = {
          info: vi.fn(),
          warn: vi.fn(),
        } as any;

        const result = formatSuccessEmail(testRecipient, testSubject, testFeedback, mockLogger);

        expect(mockLogger.info).toHaveBeenCalledWith(
          expect.objectContaining({
            bodyLength: result.body.length,
          }),
          'Success email formatted'
        );
      });
    });
  });

  describe('formatErrorEmail', () => {
    describe('ContentProcessingError formatting', () => {
      it('should format error with correct subject line', () => {
        const error = createNoContentError();
        const result = formatErrorEmail(testRecipient, error);

        expect(result.subject).toBe('Email Analysis Error');
      });

      it('should use content error template with actionable fix', () => {
        const error = createNoContentError();
        const result = formatErrorEmail(testRecipient, error);

        expect(result.body).toContain('Hi,');
        expect(result.body).toContain("I couldn't analyze your email draft:");
        expect(result.body).toContain('Please correct the issue and try again.');
        expect(result.body).toContain('---');
        expect(result.body).toContain('Email Analyzer');
      });

      it('should include user message from error', () => {
        const error = createNoContentError();
        const result = formatErrorEmail(testRecipient, error);

        expect(result.body).toContain(error.userMessage);
        expect(result.body).toContain('No content found to analyze');
      });

      it('should not include technical details in body', () => {
        const error = new ContentProcessingError(ERROR_CODES.NO_CONTENT, 'User message', {
          technicalDetail: 'This should not appear',
          stackTrace: 'Some stack trace',
        });
        const result = formatErrorEmail(testRecipient, error);

        expect(result.body).not.toContain('technicalDetail');
        expect(result.body).not.toContain('stackTrace');
        expect(result.body).not.toContain('This should not appear');
      });

      it('should return correct to address', () => {
        const error = createNoContentError();
        const result = formatErrorEmail(testRecipient, error);

        expect(result.to).toBe(testRecipient);
      });

      it('should handle NO_CONTENT error code', () => {
        const error = createNoContentError();
        const result = formatErrorEmail(testRecipient, error);

        expect(result.body).toContain('No content found to analyze');
      });

      it('should handle DOWNLOAD_FAILED error code', () => {
        const error = createDownloadFailedError();
        const result = formatErrorEmail(testRecipient, error);

        expect(result.body).toContain('Unable to download screenshots');
      });

      it('should handle INVALID_FORMAT error code', () => {
        const error = createInvalidFormatError();
        const result = formatErrorEmail(testRecipient, error);

        expect(result.body).toContain('Unsupported image formats detected');
      });

      it('should handle SIZE_EXCEEDED error code', () => {
        const error = createSizeExceededError();
        const result = formatErrorEmail(testRecipient, error);

        expect(result.body).toContain('Screenshots are too large');
      });
    });

    describe('LLMError formatting', () => {
      it('should format error with correct subject line', () => {
        const error = createLLMTimeoutError();
        const result = formatErrorEmail(testRecipient, error);

        expect(result.subject).toBe('Email Analysis Error');
      });

      it('should use LLM error template with retry suggestion', () => {
        const error = createLLMTimeoutError();
        const result = formatErrorEmail(testRecipient, error);

        expect(result.body).toContain('Hi,');
        expect(result.body).toContain('I encountered an issue while analyzing your email:');
        expect(result.body).toContain('This is usually temporary. Please try sending your draft again in a moment.');
        expect(result.body).toContain('---');
        expect(result.body).toContain('Email Analyzer');
      });

      it('should include user message from error', () => {
        const error = createLLMTimeoutError();
        const result = formatErrorEmail(testRecipient, error);

        expect(result.body).toContain(error.userMessage);
        expect(result.body).toContain('Analysis is taking longer than expected');
      });

      it('should not include technical details in body', () => {
        const error = new LLMError(LLM_ERROR_CODES.LLM_TIMEOUT, 'User message', {
          technicalDetail: 'This should not appear',
          statusCode: 504,
        });
        const result = formatErrorEmail(testRecipient, error);

        expect(result.body).not.toContain('technicalDetail');
        expect(result.body).not.toContain('statusCode');
        expect(result.body).not.toContain('504');
        expect(result.body).not.toContain('This should not appear');
      });

      it('should return correct to address', () => {
        const error = createLLMTimeoutError();
        const result = formatErrorEmail(testRecipient, error);

        expect(result.to).toBe(testRecipient);
      });

      it('should handle LLM_TIMEOUT error code', () => {
        const error = createLLMTimeoutError();
        const result = formatErrorEmail(testRecipient, error);

        expect(result.body).toContain('Analysis is taking longer than expected');
      });

      it('should handle LLM_NETWORK_ERROR error code', () => {
        const error = createLLMNetworkError();
        const result = formatErrorEmail(testRecipient, error);

        expect(result.body).toContain('Unable to reach analysis service');
      });

      it('should handle LLM_HTTP_ERROR error code', () => {
        const error = createLLMHTTPError();
        const result = formatErrorEmail(testRecipient, error);

        expect(result.body).toContain('Analysis service returned an error');
      });

      it('should handle LLM_INVALID_RESPONSE error code', () => {
        const error = createLLMInvalidResponseError();
        const result = formatErrorEmail(testRecipient, error);

        expect(result.body).toContain('Received unexpected response from analysis service');
      });
    });

    describe('Template selection', () => {
      it('should use content template for ContentProcessingError', () => {
        const error = createNoContentError();
        const result = formatErrorEmail(testRecipient, error);

        expect(result.body).toContain("I couldn't analyze your email draft:");
        expect(result.body).toContain('Please correct the issue and try again.');
      });

      it('should use LLM template for LLMError', () => {
        const error = createLLMTimeoutError();
        const result = formatErrorEmail(testRecipient, error);

        expect(result.body).toContain('I encountered an issue while analyzing your email:');
        expect(result.body).toContain('This is usually temporary. Please try sending your draft again in a moment.');
      });

      it('should differentiate templates correctly', () => {
        const contentError = createNoContentError();
        const llmError = createLLMTimeoutError();

        const contentResult = formatErrorEmail(testRecipient, contentError);
        const llmResult = formatErrorEmail(testRecipient, llmError);

        // Content error has "couldn't analyze"
        expect(contentResult.body).toContain("couldn't analyze");
        expect(llmResult.body).not.toContain("couldn't analyze");

        // LLM error has "encountered an issue"
        expect(llmResult.body).toContain('encountered an issue');
        expect(contentResult.body).not.toContain('encountered an issue');
      });
    });

    describe('Logging behavior', () => {
      it('should log error metadata for content errors', () => {
        const mockLogger = {
          info: vi.fn(),
        } as any;

        const error = createNoContentError();
        formatErrorEmail(testRecipient, error, mockLogger);

        expect(mockLogger.info).toHaveBeenCalledWith(
          {
            to: testRecipient,
            errorCode: ERROR_CODES.NO_CONTENT,
          },
          'Error email formatted'
        );
      });

      it('should log error metadata for LLM errors', () => {
        const mockLogger = {
          info: vi.fn(),
        } as any;

        const error = createLLMTimeoutError();
        formatErrorEmail(testRecipient, error, mockLogger);

        expect(mockLogger.info).toHaveBeenCalledWith(
          {
            to: testRecipient,
            errorCode: LLM_ERROR_CODES.LLM_TIMEOUT,
          },
          'Error email formatted'
        );
      });

      it('should not log error details object', () => {
        const mockLogger = {
          info: vi.fn(),
        } as any;

        const error = new ContentProcessingError(ERROR_CODES.NO_CONTENT, 'User message', {
          secretData: 'SHOULD_NOT_BE_LOGGED',
          apiKey: 'secret-key-123',
        });

        formatErrorEmail(testRecipient, error, mockLogger);

        const logCall = mockLogger.info.mock.calls[0]!;
        const logData = logCall[0];

        expect(logData).not.toHaveProperty('details');
        expect(logData).not.toHaveProperty('secretData');
        expect(logData).not.toHaveProperty('apiKey');
        expect(JSON.stringify(logData)).not.toContain('SHOULD_NOT_BE_LOGGED');
        expect(JSON.stringify(logData)).not.toContain('secret-key-123');
      });

      it('should not log user message content', () => {
        const mockLogger = {
          info: vi.fn(),
        } as any;

        const error = createNoContentError();
        formatErrorEmail(testRecipient, error, mockLogger);

        const logCall = mockLogger.info.mock.calls[0]!;
        const logData = logCall[0];

        expect(logData).not.toHaveProperty('userMessage');
        expect(logData).not.toHaveProperty('message');
        expect(JSON.stringify(logData)).not.toContain(error.userMessage);
      });

      it('should work without logger', () => {
        const error = createNoContentError();

        // Should not throw
        expect(() => {
          formatErrorEmail(testRecipient, error);
        }).not.toThrow();
      });
    });

    describe('Return value structure', () => {
      it('should return all required fields for content error', () => {
        const error = createNoContentError();
        const result = formatErrorEmail(testRecipient, error);

        expect(result).toHaveProperty('to');
        expect(result).toHaveProperty('subject');
        expect(result).toHaveProperty('body');
      });

      it('should return all required fields for LLM error', () => {
        const error = createLLMTimeoutError();
        const result = formatErrorEmail(testRecipient, error);

        expect(result).toHaveProperty('to');
        expect(result).toHaveProperty('subject');
        expect(result).toHaveProperty('body');
      });

      it('should not modify error object', () => {
        const error = createNoContentError();
        const originalCode = error.code;
        const originalMessage = error.userMessage;

        formatErrorEmail(testRecipient, error);

        expect(error.code).toBe(originalCode);
        expect(error.userMessage).toBe(originalMessage);
      });
    });

    describe('Body structure', () => {
      it('should have proper structure order for content errors', () => {
        const error = createNoContentError();
        const result = formatErrorEmail(testRecipient, error);

        const hiIndex = result.body.indexOf('Hi,');
        const problemIndex = result.body.indexOf("couldn't analyze");
        const messageIndex = result.body.indexOf(error.userMessage);
        const actionIndex = result.body.indexOf('Please correct the issue');
        const separatorIndex = result.body.indexOf('---');

        expect(hiIndex).toBeLessThan(problemIndex);
        expect(problemIndex).toBeLessThan(messageIndex);
        expect(messageIndex).toBeLessThan(actionIndex);
        expect(actionIndex).toBeLessThan(separatorIndex);
      });

      it('should have proper structure order for LLM errors', () => {
        const error = createLLMTimeoutError();
        const result = formatErrorEmail(testRecipient, error);

        const hiIndex = result.body.indexOf('Hi,');
        const problemIndex = result.body.indexOf('encountered an issue');
        const messageIndex = result.body.indexOf(error.userMessage);
        const retryIndex = result.body.indexOf('This is usually temporary');
        const separatorIndex = result.body.indexOf('---');

        expect(hiIndex).toBeLessThan(problemIndex);
        expect(problemIndex).toBeLessThan(messageIndex);
        expect(messageIndex).toBeLessThan(retryIndex);
        expect(retryIndex).toBeLessThan(separatorIndex);
      });
    });
  });
});
